#include <iostream>
#include <fstream>
#include <vector>
//#include <string>
//#include <cstdint>
//#include <cstring>

constexpr size_t HEADER_LENGTH = 29;
constexpr size_t KEY_LENGTH = 256;
const char STATIC_HEADER[HEADER_LENGTH + 1] = "RF Online by OdinTeam s(^O^)z";

// Static key as bytes
const uint8_t STATIC_KEY[KEY_LENGTH] = {
    0x10, 0x57, 0x4F, 0x74, 0x67, 0x6D, 0x43, 0x67, 0x4E, 0x6C, 0x45, 0x74, 0x55, 0x66, 0x54, 0x71,
    0x52, 0x39, 0x41, 0x4C, 0x4C, 0x5A, 0x42, 0x72, 0x6E, 0x69, 0x6F, 0x4F, 0x69, 0x7A, 0x66, 0x63,
    0x76, 0x37, 0x38, 0x42, 0x47, 0x48, 0x57, 0x6E, 0x2B, 0x50, 0x4B, 0x48, 0x49, 0x79, 0x4B, 0x63,
    0x39, 0x67, 0x74, 0x39, 0x73, 0x47, 0x36, 0x58, 0x73, 0x4C, 0x65, 0x35, 0x55, 0x51, 0x59, 0x52,
    0x38, 0x50, 0x58, 0x6D, 0x6F, 0x47, 0x4C, 0x66, 0x6F, 0x80, 0xA6, 0x90, 0xCD, 0x8E, 0x20, 0x71,
    0x54, 0x4F, 0x18, 0x98, 0x30, 0x57, 0x40, 0x53, 0x48, 0x6E, 0x51, 0x6A, 0x4C, 0x4B, 0x4D, 0x74,
    0x67, 0x46, 0x4B, 0x63, 0x51, 0x4A, 0x4B, 0x6D, 0x50, 0x51, 0x32, 0x51, 0x55, 0x55, 0x46, 0x57,
    0x34, 0x6A, 0x79, 0x68, 0x6B, 0x33, 0x50, 0x70, 0x55, 0x58, 0x31, 0x72, 0x4B, 0x67, 0x6B, 0x45,
    0x74, 0x4F, 0x61, 0x6B, 0x42, 0x49, 0x34, 0x36, 0x2E, 0x5C, 0x6D, 0x61, 0x70, 0x5C, 0x4E, 0x65,
    0x75, 0x74, 0x72, 0x61, 0x6C, 0x42, 0x5C, 0x4E, 0x65, 0x75, 0x74, 0x72, 0x61, 0x6C, 0x42, 0x2E,
    0x42, 0x53, 0x50, 0x50, 0x44, 0x41, 0x50, 0x6A, 0x32, 0x47, 0x75, 0x54, 0x70, 0x52, 0x69, 0x53,
    0x75, 0x41, 0x66, 0x56, 0x49, 0x5A, 0x67, 0x63, 0x4E, 0x65, 0x35, 0x6C, 0x5A, 0x67, 0x46, 0x6D,
    0x54, 0x4E, 0x47, 0x72, 0x30, 0x32, 0x79, 0x53, 0x34, 0x61, 0x75, 0x61, 0x51, 0x72, 0x77, 0x4B,
    0x34, 0x67, 0x48, 0x6B, 0x49, 0x59, 0x6F, 0x54, 0x61, 0x79, 0x34, 0x68, 0x4C, 0x63, 0x33, 0x4D,
    0x66, 0x4E, 0x6D, 0x57, 0x7A, 0x44, 0x65, 0x4B, 0x4A, 0x74, 0x37, 0x51, 0x35, 0x52, 0x39, 0x79,
    0x63, 0x75, 0x74, 0x66, 0x6D, 0x55, 0x75, 0x53, 0x2B, 0x62, 0x59, 0x2B, 0x39, 0x39, 0x7A, 0x41
};

std::string get_output_path(const std::string& inputPath) {
    std::string output = inputPath;
    size_t dot = output.find_last_of('.');
    if (dot != std::string::npos) {
        output.replace(dot, output.size() - dot, ".edf");
    }
    else {
        output += ".edf";
    }
    return output;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <input_file>" << std::endl;
        return 1;
    }

    std::string inputPath = argv[1];
    std::ifstream inFile(inputPath, std::ios::binary | std::ios::ate);
    if (!inFile) {
        std::cerr << "Failed to open: " << inputPath << std::endl;
        return 1;
    }

    std::streamsize size = inFile.tellg();
    inFile.seekg(0);
    std::vector<uint8_t> data(size);
    inFile.read(reinterpret_cast<char*>(data.data()), size);
    inFile.close();

    std::vector<uint8_t> out;
    out.insert(out.end(), STATIC_HEADER, STATIC_HEADER + HEADER_LENGTH);

    // Write file size (as little-endian 4-byte int)
    uint32_t fileSize = static_cast<uint32_t>(size);
    out.insert(out.end(), reinterpret_cast<uint8_t*>(&fileSize), reinterpret_cast<uint8_t*>(&fileSize) + 4);

    // Encrypt content
    std::vector<uint8_t> key(STATIC_KEY, STATIC_KEY + KEY_LENGTH); // copy key to modify it

    // Body encryption
    bool even = true;
    for (size_t i = 0; i < size; ++i) {
        uint8_t k = key[(i + 1) % KEY_LENGTH];
        data[i] = even ? data[i] + k : data[i] - k;
        even = !even;
    }
    out.insert(out.end(), data.begin(), data.end());

    // Encrypt key
    for (int i = 0; i < KEY_LENGTH; i += 2)
        std::swap(key[i], key[i + 1]);

    for (int i = 0; i < KEY_LENGTH / 2; ++i)
        std::swap(key[i], key[KEY_LENGTH - 1 - i]);

    const uint8_t DIGIT[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };
    even = true;
    for (int i = 0; i < KEY_LENGTH; ++i) {
        uint8_t d = DIGIT[(i + 1) % 8];
        key[i] = even ? key[i] + d : key[i] - d;
        even = !even;
    }

    // Append encrypted key
    out.insert(out.end(), key.begin(), key.end());

    std::string outPath = get_output_path(inputPath);
    std::ofstream outFile(outPath, std::ios::binary);
    outFile.write(reinterpret_cast<char*>(out.data()), out.size());
    outFile.close();

    std::cout << "Encrypted EDF file saved to: " << outPath << std::endl;
    return 0;
}
